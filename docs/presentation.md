# Calendar App API

A proof-of-concept calendar api using fastapi and postgres.

It handles user-registration as well as CRUD operations for events for a calendar.

## App
FastAPI was chosen since it's fast (for Python) and is the second most popular Python framework (after Django) and it comes with niceties like autogenerated OpenAPI docs (which then makes testing easy and allows autogenerating SDKs in any other language possible).

Pydantic was chosen since it's recommended by FastAPI to help with the auto-documentation and make it clear how requests and responses should be structured.

SQLAlchemy was used to interact with the database and provide quality-of-life features like preventing sql injections, ORMs (which is a matter of taste), etc.

Alembic for database migrations (if you don't want to use Kubernetes) which allows version control of the database design.

Python's `venv` was used (instead of something like poetry) since it's part of the standard library and still the most common way of managing packages

## Directory Structure
```
.
├── alembic
│   └── versions
├── app
│   ├── api
│   │   └── v1
│   │       └── endpoints
│   ├── crud
│   ├── models
│   └── schemas
├── assets
├── docs
│   └── setup
├── iac
│   ├── kubernetes
│   ├── tf
│   └── vendor_clouds
├── requirements
└── tests
```

## Database Schema
[!ERDiagram](/assets/erdiagram.png)

## Kubernetes 
We use Kubernetes to allow for convenient management and scalability.

### Kubernetes Operators
A major reason why Kubernetes has remained popular is because it is extensible. One way of extending Kubernetes is through Operators which extends Kubernetes to make use of Custom Resources to manage apps beyond what is already built into Kubernetes (like pods, services, etc.). A common way of deploying an operator is to add the Custom Resource Definition (CRD) along with it's associated controller to your cluster.

Postgres: Initially, Kubernetes was designed for stateless applications. Historically, people found it annoying to manage stateful workloads through Kubernetes. 
Traditionally, you'd have to use (among others):
- persistent volumes - the "physical" volume on the host machine
- persistent volume claims - the "request" for the platform to create a persist volume. This is to provide durable database storage (if you don't do this, you'll lose data if a node goes down)
- statefulsets - runs a group of Pods, and maintains a sticky identity for each of those Pods. This is useful for managing applications that need persistent storage or a stable, unique network identity.
- jobs - to handle initial configuration
- secrets - to store sensitive info
- services - to expose the database to other pods for communication
- etc.

But then complexity arises when you want to:
- self heal - automatic failover of the primary instance by promoting the most aligned replica
- scale up/down
- run in-place or rolling updates
- run backups
- do declarative management of postgres databases, roles, users, groups, etc.
- and do other standard database things

For this reason, we use [CloudNativePG](https://cloudnative-pg.io/documentation/1.25/) which is a Kubernetes operator that supports the full lifecycle of a highly-available Postgres database cluster with a primary/standby architecture, using native straming replication. In our setup, the fastapi backend(s) only connnect to the primary (-rw primary service). If this primary becomes unavailable, it promotes another primary and makes sure that traffic from apps are redirected to it.

To handle migrations, we provide alembic migrations if you want to use python without docker, but we also let you to do the migrations through another Kubernetes operator called [Atlas](https://atlasgo.io/getting-started/). This gives us a language-independent tool of creating declarative database state. Unlike alembic and other traditional migration tools, it plans the necessary schema migrations for us.

## Infrastructure as Code
We use OpenTofu (or Terraform) as our infrastructure as code choice since it's probably the most popular. It allows us to provision and manage resources in a declarative way (meaning it'll figure out how to achieve your desired state).


TODO: actually provision cloud resources with some cloud of choice using terraform. I briefly tried it with Oracle Cloud, but ran out of time.

## CI/CD
We use Github Actions which is a very common tool and makes sense since our code is on Github. We automate unit tests, builds, and (TODO: deployments) through this pipeline.

### Tests
For unit tests, we use [pytest](https://docs.pytest.org/en/stable/) since it's the most popular testing framework for python.


## Other helpful tools I used
- [https://github.com/jrhouston/tfk8s](tfk8s) - to autogenerate Terraform HCL from Kubernetes YAML manifests (though some tweaks were needed like adding namespaces and fixing Secrets)
- [https://k9scli.io/](k9s) - useful terminal-based UI tool to interact with Kubernetes
- [https://k3s.io/](k3s) - a lightweight kubernetes that is production ready, yet still works for local development
